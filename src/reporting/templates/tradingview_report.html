<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>/*TITLE*/ (v2)</title>
    <script src="https://unpkg.com/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            margin: 0;
            padding: 0;
            background-color: #131722;
            color: #d1d5db;
        }

        /* Layout */
        .header {
            padding: 12px 20px;
            background-color: #1e222d;
            border-bottom: 1px solid #2a2e39;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: #d1d4dc;
        }

        .meta {
            font-size: 13px;
            color: #787b86;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .full-width-container {
            margin: 0;
            padding: 20px 20px 0 20px;
            /* Top/Side padding, no bottom to hug container */
        }

        /* Chart Controls */
        .controls {
            margin-bottom: 10px;
            display: flex;
            gap: 15px;
            font-size: 13px;
        }

        .control-item {
            display: flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .control-item input {
            margin-right: 6px;
        }

        #tv-chart {
            width: 100%;
            height: 600px;
            border: 1px solid #2a2e39;
            border-radius: 4px;
            position: relative;
            background: #1e222d;
            margin-bottom: 30px;
            overflow: hidden;
        }

        #error-display {
            color: #ef5350;
            padding: 20px;
            display: none;
            background: #2a1010;
            border: 1px solid #501010;
            margin: 20px;
        }

        /* Legend */
        .legend {
            position: absolute;
            left: 12px;
            top: 12px;
            z-index: 10;
            font-size: 14px;
            font-family: 'Monaco', 'Consolas', monospace;
            line-height: 18px;
            color: #d1d4dc;
            pointer-events: none;
            background: rgba(30, 34, 45, 0.7);
            padding: 4px 8px;
            border-radius: 4px;
        }

        /* Tables */
        .section-title {
            font-size: 16px;
            font-weight: 600;
            color: #d1d4dc;
            margin-bottom: 15px;
            border-left: 4px solid #2962FF;
            padding-left: 10px;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
            margin-bottom: 30px;
            background: #1e222d;
            border-radius: 4px;
            overflow: hidden;
        }

        .data-table th,
        .data-table td {
            border: 1px solid #444;
            padding: 8px;
            text-align: left;
        }

        .data-table th {
            background-color: #333;
            position: sticky;
            top: 0;
        }

        .data-table tr:nth-child(even) {
            background-color: #262626;
        }

        .data-table tr:hover {
            background-color: #333;
        }

        h1 {
            margin: 0;
            font-size: 20px;
            padding: 10px 20px;
            background: #252526;
        }

        h2 {
            color: #fff;
            margin-top: 0;
        }

        .time-link {
            color: #4fc3f7;
            text-decoration: none;
            cursor: pointer;
            border-bottom: 1px dashed #4fc3f7;
        }

        .time-link:hover {
            color: #81d4fa;
            border-bottom-style: solid;
        }

        /* Utility */
        .text-green {
            color: #26a69a;
        }

        .text-red {
            color: #ef5350;
        }

        .text-right {
            text-align: right !important;
        }

        .focus-btn {
            background-color: #2196F3;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            margin-right: 5px;
        }

        .focus-btn:hover {
            background-color: #1976D2;
        }
    </style>
</head>

<body>
    <div class="full-width-container">
        <h1>Trading Strategy Report</h1>
        <div id="error-display"
            style="display:none; color: #ef5350; background: #2a1010; padding: 10px; border-bottom: 1px solid #501010;">
        </div>

        <div class="control-panel">
            <label style="display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="check-equity" checked style="margin-right: 8px;"> Equity Curve
            </label>
            <label style="display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="check-benchmark" checked style="margin-right: 8px;"> Pure Grid
                (Benchmark)
            </label>
            <label style="display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="check-markers" checked style="margin-right: 8px;"> Trades
            </label>
        </div>

        <div id="tv-chart" class="chart-container">
            <div id="legend" class="legend"></div>
        </div>
    </div>

    <div class="container">
        <h2>Performance Metrics</h2>
        /*INJECT_METRICS*/

        <h2>Trade Analysis</h2>
        /*INJECT_DISTRIBUTION*/
        /*INJECT_ANALYSIS*/

        <h2>Trade List</h2>
        /*INJECT_TRADES*/
    </div>

    <script>
        try {
            // Data Injection
            const candleData = /*INJECT_CANDLES*/;
            const equityData = /*INJECT_EQUITY*/;
            const benchmarkData = /*INJECT_BENCHMARK_EQUITY*/;
            const allMarkers = /*INJECT_MARKERS*/; // Contains full data
            const volumeData = /*INJECT_VOLUME*/;

            // ------------------------------------------
            // Re-basing Logic (Normalize Equity to Price)
            // ------------------------------------------
            let scaleFactor = 1.0;
            let normalizedEquity = equityData;
            let normalizedBenchmark = benchmarkData;

            if (candleData.length > 0 && equityData.length > 0) {
                const startEquityObj = equityData[0];
                const startEquity = startEquityObj.value;
                const startTime = startEquityObj.time;

                // Find candle at or closest to startEquity time within a reasonable window
                // Since both are sorted by time
                let matchCandle = candleData.find(c => c.time >= startTime);

                // Fallback: If no future candle (e.g. Equity is at end?), use last candle? 
                // Or if Equity starts BEFORE all candles? Use first candle.
                if (!matchCandle && candleData.length > 0) {
                    matchCandle = candleData[0];
                }

                if (matchCandle && startEquity > 0) {
                    const startPrice = matchCandle.close;
                    scaleFactor = startPrice / startEquity;
                    normalizedEquity = equityData.map(d => ({
                        time: d.time,
                        value: d.value * scaleFactor,
                        original: d.value // Store original for legend
                    }));

                    normalizedBenchmark = benchmarkData.map(d => ({
                        time: d.time,
                        value: d.value * scaleFactor,
                        original: d.value
                    }));
                }
            }

            // Injected Constants
            const INTERVAL = /*INJECT_INTERVAL*/;

            const chartContainer = document.getElementById('tv-chart');
            const chart = LightweightCharts.createChart(chartContainer, {
                width: chartContainer.clientWidth,
                height: chartContainer.clientHeight, // Dynamic height
                layout: {
                    backgroundColor: '#1e1e1e',
                    textColor: '#d1d4dc'
                },
                grid: {
                    vertLines: {
                        color: '#2b2b43'
                    },
                    horzLines: {
                        color: '#2b2b43'
                    }
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                },
                rightPriceScale: {
                    borderColor: '#2a2e39',
                    visible: true,
                    scaleMargins: { top: 0.1, bottom: 0.1 },
                },
                leftPriceScale: {
                    visible: true,
                    borderColor: '#2a2e39',
                    scaleMargins: { top: 0.1, bottom: 0.1 },
                },
                timeScale: {
                    borderColor: '#2a2e39',
                    timeVisible: true,
                    secondsVisible: false,
                },
            });



            // 1. Candlestick Series
            const candlestickSeries = chart.addCandlestickSeries({
                upColor: '#089981',
                downColor: '#f23645',
                borderVisible: false,
                wickUpColor: '#089981',
                wickDownColor: '#f23645',
                priceScaleId: 'right',
            });
            candlestickSeries.setData(candleData);

            // 2. Volume Series
            const volumeSeries = chart.addHistogramSeries({
                color: '#26a69a',
                priceFormat: { type: 'volume' },
                priceScaleId: '', // Overlay
            });
            volumeSeries.priceScale().applyOptions({
                scaleMargins: { top: 0.8, bottom: 0 },
            });
            volumeSeries.setData(volumeData);



            const equitySeries = chart.addLineSeries({
                color: '#2962FF',
                lineWidth: 2,
                priceScaleId: 'right', // Align with Price (Re-based)
                title: 'Equity',
                crosshairMarkerVisible: true,
                lastValueVisible: false,
            });
            equitySeries.setData(normalizedEquity);

            // Benchmark Series (Pure Grid)
            const benchmarkSeries = chart.addLineSeries({
                color: '#787b86',
                lineWidth: 1,
                lineStyle: LightweightCharts.LineStyle.Dashed,
                priceScaleId: 'right',
                title: 'Pure Grid',
                crosshairMarkerVisible: false,
                lastValueVisible: false,
            });
            benchmarkSeries.setData(normalizedBenchmark);

            // ------------------------------------------
            // Marker Logic
            // ------------------------------------------
            const checkMarkers = document.getElementById('check-markers');
            const checkBenchmark = document.getElementById('check-benchmark');
            const checkEquity = document.getElementById('check-equity');

            function updateMarkers() {
                if (!checkMarkers.checked) {
                    candlestickSeries.setMarkers([]);
                    return;
                }

                // Always show text by default since we removed the toggle for simplicity
                candlestickSeries.setMarkers(allMarkers);
            }

            checkMarkers.addEventListener('change', updateMarkers);
            // checkLabels removed
            checkBenchmark.addEventListener('change', function () {
                benchmarkSeries.applyOptions({ visible: this.checked });
            });

            checkEquity.addEventListener('change', function () {
                equitySeries.applyOptions({ visible: this.checked });
            });

            // Initial Load
            updateMarkers();

            // ------------------------------------------
            // Legend Logic
            // ------------------------------------------
            const legend = document.getElementById('legend');
            const formatPrice = (price) => price.toFixed(2);
            const formatVol = (vol) => (vol >= 1e6) ? (vol / 1e6).toFixed(2) + 'M' : (vol / 1e3).toFixed(2) + 'K';

            // Throttled Crosshair Move
            let isScheduled = false;
            let lastParam = null;

            chart.subscribeCrosshairMove((param) => {
                lastParam = param;
                if (!isScheduled) {
                    requestAnimationFrame(updateLegend);
                    isScheduled = true;
                }
            });

            function updateLegend() {
                isScheduled = false;
                const param = lastParam;

                // Defensive check for param validity
                // Ensure param, param.time, and param.point exist before using them
                let validCrosshair = (
                    param &&
                    param.time &&
                    param.point &&
                    param.point.x >= 0 &&
                    param.point.y >= 0
                );

                let time = null;
                if (validCrosshair) {
                    time = param.time;
                } else if (candleData.length > 0) {
                    time = candleData[candleData.length - 1].time;
                }

                if (!time) {
                    legend.innerHTML = '';
                    return;
                }

                let candle = null;
                let equity = null;
                let volume = null;
                let benchmark = null;

                // Safe access to seriesData
                if (validCrosshair && param && param.seriesData) {
                    try {
                        candle = param.seriesData.get(candlestickSeries);
                        equity = param.seriesData.get(equitySeries);

                        benchmark = param.seriesData.get(benchmarkSeries);
                        volume = param.seriesData.get(volumeSeries);
                    } catch (e) {
                        // Ignore lookup errors
                    }
                }

                // Fallback lookup if undefined (e.g. crosshair on empty space or fallback mode)
                if (!candle && candleData.length > 0) {
                    // Binary search or find? Data is sorted. Simple find for now or map?
                    // Optimization: If we assume simple array...
                    // Let's use simple find for robustness, though slow for big data. 
                    // Actually, for fallback, we know we want the last one usually.
                    if (!validCrosshair) {
                        candle = candleData[candleData.length - 1];
                        equity = equityData.find(e => e.time === time); // Might be slow
                        volume = volumeData.find(v => v.time === time);
                    } else {
                        // Hovering but no data? (Gap)
                    }
                }

                let components = [];

                // Helper to pad
                const pad = (n) => n.toString().padStart(2, '0');
                const dateStr = new Date(time * 1000).toLocaleString(); // Simple local format

                // components.push(`<span>${dateStr}</span>`); // Optional: Date in legend? TV puts it on axis.

                if (candle) {
                    const color = candle.close >= candle.open ? '#089981' : '#f23645';
                    components.push(`<span style="color:${color}">O: ${formatPrice(candle.open)}  H: ${formatPrice(candle.high)}  L: ${formatPrice(candle.low)}  C: ${formatPrice(candle.close)}</span>`);
                }

                if (equity) {
                    // Handle both TV object (value) and raw object (value)
                    const val = equity.value !== undefined ? equity.value : equity;
                    // We need original value if normalized
                    // But wait, param.seriesData returns the Re-based value if using setData(normalized).
                    // We attached 'original' to the data points.
                    // TV 'seriesData' returns the original data object passed to setData! 
                    // So 'equity' object should have '.original' if we passed it.

                    const displayVal = (equity.original !== undefined) ? equity.original : (val / scaleFactor);
                    components.push(`<span style="color:#2962FF">Eq: ${formatPrice(displayVal)}</span>`);

                }

                if (benchmark) {
                    const val = benchmark.value !== undefined ? benchmark.value : benchmark;
                    const displayVal = (benchmark.original !== undefined) ? benchmark.original : (val / scaleFactor);
                    components.push(`<span style="color:#787b86">Pure: ${formatPrice(displayVal)}</span>`);
                }

                if (volume) {
                    const val = volume.value !== undefined ? volume.value : volume;
                    components.push(`Vol: ${formatVol(val)}`);
                }

                legend.innerHTML = components.join(' &nbsp; | &nbsp; ');
            }

            chart.timeScale().fitContent();

            window.addEventListener('resize', () => {
                chart.resize(chartContainer.clientWidth, chartContainer.clientHeight);
            });



            // ------------------------------------------
            // Dynamic Re-basing on Scroll/Zoom
            // ------------------------------------------
            let isUpdatingData = false;
            const debouncedUpdate = (function (fn, ms) {
                let timer = 0;
                return function () {
                    clearTimeout(timer);
                    timer = setTimeout(fn, ms);
                }
            });

            const handleRangeChange = debouncedUpdate(() => {
                if (isUpdatingData) return;

                const logicalRange = chart.timeScale().getVisibleLogicalRange();
                if (!logicalRange) return;

                // Find visible data indices
                // Note: LightWeightCharts doesn't give direct data index access from logical range easily for custom arrays
                // But logical range roughly maps to index if we assume 1 bar = 1 step.
                // However, equityData might not match candleData one-to-one perfectly if there are gaps?
                // Assuming 5m timeframe, they should match.
                // Let's find first visible time from chart's timeScale is safer?

                // Actually, we can just iterate data to find first point >= logicalRange.from
                // But 'from' is an index (float).
                // Let's try to convert logical range to time is hard without API.
                // Better: Chart provides coordinateToTime? No.

                // Simpler: Use the bars series to get the time range?
                // "The logical range is a range of indexes."
                // So logicalRange.from (rounded) is the index in the MAIN series (Candles).

                const fromIndex = Math.max(0, Math.floor(logicalRange.from));
                if (fromIndex >= candleData.length) return;

                const firstVisibleCandle = candleData[fromIndex];
                if (!firstVisibleCandle) return;

                const visibleStartTime = firstVisibleCandle.time;

                // 2. Find Alignment Point
                // We want to align Equity to Price at the FIRST MOMENT where both exist within (or after) the visible range.
                const firstEquityTime = equityData.length > 0 ? equityData[0].time : 0;
                const alignmentTime = Math.max(visibleStartTime, firstEquityTime);

                // Find data points at alignmentTime
                const refCandle = candleData.find(c => c.time >= alignmentTime);
                const refEquity = equityData.find(e => e.time >= alignmentTime);

                if (!refCandle || !refEquity) return;

                if (refEquity.value > 0) {
                    const newFactor = refCandle.close / refEquity.value;


                    const newNormalized = equityData.map(d => ({
                        time: d.time,
                        value: d.value * newFactor,
                        original: d.value
                    }));
                    const newBenchmark = benchmarkData.map(d => ({
                        time: d.time,
                        value: d.value * newFactor,
                        original: d.value
                    }));

                    isUpdatingData = true;
                    equitySeries.setData(newNormalized);
                    benchmarkSeries.setData(newBenchmark);
                    isUpdatingData = false;
                }

            }, 50); // 50ms debounce

            chart.timeScale().subscribeVisibleLogicalRangeChange(handleRangeChange);

            // ------------------------------------------
            // Navigation Helper
            // ------------------------------------------
            window.scrollToTimestamp = function (ts) {
                if (!chart) {
                    console.error("Chart not initialized");
                    return;
                }
                console.log("Navigating to timestamp:", ts);

                // Focus on +/- 50 candles window
                const range = 50 * INTERVAL;
                chart.timeScale().setVisibleRange({
                    from: ts - range,
                    to: ts + range
                });
            };

        } catch (e) {
            document.getElementById('error-display').style.display = 'block';
            document.getElementById('error-display').textContent = 'Chart Error: ' + e.message + '\n' + e.stack;
        }

    </script>

</body>

</html>