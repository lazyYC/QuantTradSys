<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>/*TITLE*/</title>
    <script src="https://unpkg.com/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            margin: 0;
            padding: 0;
            background-color: #131722;
            /* TradingView Dark Background */
            color: #d1d5db;
        }

        /* Layout */
        .header {
            padding: 12px 20px;
            background-color: #1e222d;
            border-bottom: 1px solid #2a2e39;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: #d1d4dc;
        }

        .meta {
            font-size: 13px;
            color: #787b86;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .full-width-container {
            margin: 0;
            padding: 20px 20px 0 20px;
            /* Top/Side padding, no bottom to hug container */
        }

        /* Chart Controls */
        .controls {
            margin-bottom: 10px;
            display: flex;
            gap: 15px;
            font-size: 13px;
        }

        .control-item {
            display: flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .control-item input {
            margin-right: 6px;
        }

        #chart-container {
            width: 100%;
            height: 600px;
            border: 1px solid #2a2e39;
            border-radius: 4px;
            position: relative;
            background: #1e222d;
            margin-bottom: 30px;
            overflow: hidden;
        }

        #error-display {
            color: #ef5350;
            padding: 20px;
            display: none;
            background: #2a1010;
            border: 1px solid #501010;
            margin: 20px;
        }

        /* Legend */
        .legend {
            position: absolute;
            left: 12px;
            top: 12px;
            z-index: 10;
            font-size: 14px;
            font-family: 'Monaco', 'Consolas', monospace;
            line-height: 18px;
            color: #d1d4dc;
            pointer-events: none;
            background: rgba(30, 34, 45, 0.7);
            padding: 4px 8px;
            border-radius: 4px;
        }

        /* Tables */
        .section-title {
            font-size: 16px;
            font-weight: 600;
            color: #d1d4dc;
            margin-bottom: 15px;
            border-left: 4px solid #2962FF;
            padding-left: 10px;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
            margin-bottom: 30px;
            background: #1e222d;
            border-radius: 4px;
            overflow: hidden;
        }

        .data-table th,
        .data-table td {
            text-align: left;
            padding: 10px 15px;
            border-bottom: 1px solid #2a2e39;
        }

        .data-table th {
            background-color: #2a2e39;
            font-weight: 500;
            color: #d1d4dc;
        }

        .data-table tr:last-child td {
            border-bottom: none;
        }

        .data-table tr:hover {
            background-color: #2a2e39;
        }

        /* Utility */
        .text-green {
            color: #26a69a;
        }

        .text-red {
            color: #ef5350;
        }

        .text-right {
            text-align: right !important;
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>/*TITLE*/</h1>
        <div class="meta">/*STRATEGY*/ | /*STUDY*/</div>
    </div>

    <div id="error-display"></div>

    <div class="full-width-container">
        <!-- Controls -->
        <div class="controls">
            <label class="control-item">
                <input type="checkbox" id="check-markers" checked>
                Show Trades
            </label>
            <label class="control-item">
                <input type="checkbox" id="check-labels" checked>
                Show Price Labels
            </label>
        </div>

        <!-- Chart -->
        <div id="chart-container">
            <div class="legend" id="legend"></div>
        </div>
    </div>

    <div class="container">
        <!-- Metrics -->
        <div class="section-title">Performance Metrics</div>
        /*INJECT_METRICS*/

        <!-- Distribution -->
        <div class="section-title">Trade Distribution</div>
        /*INJECT_DISTRIBUTION*/
    </div>

    <script>
        try {
            // Data Injection
            const candleData = /*INJECT_CANDLES*/;
            const equityData = /*INJECT_EQUITY*/;
            const allMarkers = /*INJECT_MARKERS*/; // Contains full data
            const volumeData = /*INJECT_VOLUME*/;

            // ------------------------------------------
            // Re-basing Logic (Normalize Equity to Price)
            // ------------------------------------------
            let scaleFactor = 1.0;
            let normalizedEquity = equityData;

            if (candleData.length > 0 && equityData.length > 0) {
                const startEquityObj = equityData[0];
                const startEquity = startEquityObj.value;
                const startTime = startEquityObj.time;

                // Find candle at or closest to startEquity time within a reasonable window
                // Since both are sorted by time
                let matchCandle = candleData.find(c => c.time >= startTime);

                // Fallback: If no future candle (e.g. Equity is at end?), use last candle? 
                // Or if Equity starts BEFORE all candles? Use first candle.
                if (!matchCandle && candleData.length > 0) {
                    matchCandle = candleData[0];
                }

                if (matchCandle && startEquity > 0) {
                    const startPrice = matchCandle.close;
                    scaleFactor = startPrice / startEquity;
                    normalizedEquity = equityData.map(d => ({
                        time: d.time,
                        value: d.value * scaleFactor,
                        original: d.value // Store original for legend
                    }));
                }
            }

            // Chart Properties
            const chartOptions = {
                layout: {
                    textColor: '#d1d4dc',
                    background: { type: 'solid', color: '#1e222d' },
                },
                grid: {
                    vertLines: { color: '#2a2e39' },
                    horzLines: { color: '#2a2e39' },
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                },
                rightPriceScale: {
                    borderColor: '#2a2e39',
                    visible: true,
                    scaleMargins: { top: 0.1, bottom: 0.1 },
                },
                leftPriceScale: {
                    visible: true,
                    borderColor: '#2a2e39',
                    scaleMargins: { top: 0.1, bottom: 0.1 },
                },
                timeScale: {
                    borderColor: '#2a2e39',
                    timeVisible: true,
                    secondsVisible: false,
                },
            };

            const container = document.getElementById('chart-container');
            const chart = LightweightCharts.createChart(container, chartOptions);

            // 1. Candlestick Series
            const candlestickSeries = chart.addCandlestickSeries({
                upColor: '#089981',
                downColor: '#f23645',
                borderVisible: false,
                wickUpColor: '#089981',
                wickDownColor: '#f23645',
                priceScaleId: 'right',
            });
            candlestickSeries.setData(candleData);

            // 2. Volume Series
            const volumeSeries = chart.addHistogramSeries({
                color: '#26a69a',
                priceFormat: { type: 'volume' },
                priceScaleId: '', // Overlay
            });
            volumeSeries.priceScale().applyOptions({
                scaleMargins: { top: 0.8, bottom: 0 },
            });
            volumeSeries.setData(volumeData);


            // 3. Equity Series
            const equitySeries = chart.addLineSeries({
                color: '#2962FF',
                lineWidth: 2,
                priceScaleId: 'right', // Align with Price (Re-based)
                title: 'Equity',
                crosshairMarkerVisible: true,
                lastValueVisible: false, // Hide normalized value on axis label to avoid confusion? Or show it? 
                // Showing it on axis might be confusing (showing 90k for equity). 
                // But user wants to compare "amplitude".
                // Let's keep it visible but maybe format it? 
                // Actually, user wants alignment.
            });
            equitySeries.setData(normalizedEquity);

            // ------------------------------------------
            // Marker Logic
            // ------------------------------------------
            const checkMarkers = document.getElementById('check-markers');
            const checkLabels = document.getElementById('check-labels');

            function updateMarkers() {
                if (!checkMarkers.checked) {
                    candlestickSeries.setMarkers([]);
                    return;
                }

                const showText = checkLabels.checked;
                const currentMarkers = allMarkers.map(m => ({
                    ...m,
                    text: showText ? m.text : undefined // Remove text if unchecked
                }));
                candlestickSeries.setMarkers(currentMarkers);
            }

            checkMarkers.addEventListener('change', updateMarkers);
            checkLabels.addEventListener('change', updateMarkers);

            // Initial Load
            updateMarkers();

            // ------------------------------------------
            // Legend Logic
            // ------------------------------------------
            const legend = document.getElementById('legend');
            const formatPrice = (price) => price.toFixed(2);
            const formatVol = (vol) => (vol >= 1e6) ? (vol / 1e6).toFixed(2) + 'M' : (vol / 1e3).toFixed(2) + 'K';

            // Throttled Crosshair Move
            let isScheduled = false;
            let lastParam = null;

            function updateLegend() {
                const param = lastParam;
                isScheduled = false;

                if (!param || !param.time) {
                    // keeping last value or clear? let's clear if out of chart
                    // legend.innerHTML = '';
                    return;
                }

                const candle = param.seriesData.get(candlestickSeries);
                const equity = param.seriesData.get(equitySeries);
                const volume = param.seriesData.get(volumeSeries);

                let components = [];
                if (candle) {
                    const color = candle.close >= candle.open ? '#089981' : '#f23645';
                    components.push(`<span style="color:${color}">O:${formatPrice(candle.open)} H:${formatPrice(candle.high)} L:${formatPrice(candle.low)} C:${formatPrice(candle.close)}</span>`);
                }
                if (equity) {
                    const originalVal = (equity.original !== undefined) ? equity.original : (equity.value / scaleFactor);
                    components.push(`<span style="color:#2962FF">Eq:${formatPrice(originalVal)}</span>`);
                }
                if (volume) {
                    components.push(`Vol:${formatVol(volume.value)}`);
                }

                legend.innerHTML = components.join(' &nbsp; | &nbsp; ');
            }

            chart.subscribeCrosshairMove((param) => {
                lastParam = param;
                if (!isScheduled) {
                    requestAnimationFrame(updateLegend);
                    isScheduled = true;
                }
            });

            chart.timeScale().fitContent();

            window.addEventListener('resize', () => {
                chart.resize(container.clientWidth, container.clientHeight);
            });



            // ------------------------------------------
            // Dynamic Re-basing on Scroll/Zoom
            // ------------------------------------------
            let isUpdatingData = false;
            const debouncedUpdate = (function (fn, ms) {
                let timer = 0;
                return function () {
                    clearTimeout(timer);
                    timer = setTimeout(fn, ms);
                }
            });

            const handleRangeChange = debouncedUpdate(() => {
                if (isUpdatingData) return;

                const logicalRange = chart.timeScale().getVisibleLogicalRange();
                if (!logicalRange) return;

                // Find visible data indices
                // Note: LightWeightCharts doesn't give direct data index access from logical range easily for custom arrays
                // But logical range roughly maps to index if we assume 1 bar = 1 step.
                // However, equityData might not match candleData one-to-one perfectly if there are gaps?
                // Assuming 5m timeframe, they should match.
                // Let's find first visible time from chart's timeScale is safer?

                // Actually, we can just iterate data to find first point >= logicalRange.from
                // But 'from' is an index (float).
                // Let's try to convert logical range to time is hard without API.
                // Better: Chart provides coordinateToTime? No.

                // Simpler: Use the bars series to get the time range?
                // "The logical range is a range of indexes."
                // So logicalRange.from (rounded) is the index in the MAIN series (Candles).

                const fromIndex = Math.max(0, Math.floor(logicalRange.from));
                if (fromIndex >= candleData.length) return;

                const firstVisibleCandle = candleData[fromIndex];
                if (!firstVisibleCandle) return;

                const visibleStartTime = firstVisibleCandle.time;

                // 2. Find Alignment Point
                // We want to align Equity to Price at the FIRST MOMENT where both exist within (or after) the visible range.
                const firstEquityTime = equityData.length > 0 ? equityData[0].time : 0;
                const alignmentTime = Math.max(visibleStartTime, firstEquityTime);

                // Find data points at alignmentTime
                const refCandle = candleData.find(c => c.time >= alignmentTime);
                const refEquity = equityData.find(e => e.time >= alignmentTime);

                if (!refCandle || !refEquity) return;

                if (refEquity.value > 0) {
                    const newFactor = refCandle.close / refEquity.value;

                    const newNormalized = equityData.map(d => ({
                        time: d.time,
                        value: d.value * newFactor,
                        original: d.value
                    }));

                    isUpdatingData = true;
                    equitySeries.setData(newNormalized);
                    isUpdatingData = false;
                }

            }, 50); // 50ms debounce

            chart.timeScale().subscribeVisibleLogicalRangeChange(handleRangeChange);

        } catch (e) {
            document.getElementById('error-display').style.display = 'block';
            document.getElementById('error-display').textContent = 'Chart Error: ' + e.message + '\n' + e.stack;
        }

    </script>

</body>

</html>